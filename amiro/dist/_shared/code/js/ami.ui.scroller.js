/** * This is version 2.0 of AMI.slider. * The html structure must be like <wrapper><clipper><container /></clipper><pad /></wrapper> * No paddings for slides! */AMI.UI.Scroller = {	// AMI.UI.Scroller size // 0 means infinity	DefaultClipperSizeX : 3,	DefaultClipperSizeY : 0,	//DefaultContainerSizeX : 0,	DefaultContainerSizeY : 0,		// html classnames for key blocks	ContainerFix : "container",	ClipperFix : "clipper",	WrapperFix : "wrapper",			// Pad classes	PadClass : "slider-pad", // Blocks, that contain arrows for slider navigation	LeftArrow : "slider-pad__arrow-left", // we clicking on LeftArrow, slider goes left	RightArrow : "slider-pad__arrow-right",	UpArrow : "slider-pad__arrow-up",	DownArrow : "slider-pad__arrow-down",	DisabledArrow : "slider-pad__arrow_disabled", // modifier indicating that arrow is disabled and cannot be clicked	ColsModifierPrefix : "_cols_",		Wrappers : [],		// Arrows	Left : [],	Right : [],		exception_class_words : Array( 'splitter' ), // if word is part of className of "slide" - this is not a slide		/**	 * @returns true if browser is supported	 */	browserIsSupported : function()	{		var rv = 10; // IE version		if (navigator.appName == 'Microsoft Internet Explorer')		{			var ua = navigator.userAgent;			var re  = new RegExp("MSIE ([0-9]{1,}[\.0-9]{0,})");			if (re.exec(ua) != null)				rv = parseFloat( RegExp.$1 );		}				if (rv <= 6) return false;				return true;	},	/**	 * Initializing all sliders on page. IE6 or lower not supported.	 *	 * Finding all blocks with className this.PadClass. Then finding key-blocks ((wrapper), clipper and container) around each Pad.	 * If container bigger than clipper - than arrows will be created.	 */	init : function()	{		if (this.browserIsSupported() && typeof AMI.find === 'function')		{			this.Pads = AMI.$('.' + this.PadClass);			if (this.Pads)			{				this.Clippers = [];				this.ClippersWidth = [];				// Getting Clippers width, finding key-blocks				for ( var j = 0 ; j <= this.Pads.length - 1 ; j++ )				{					this.Clippers[j] = this.findFirstKeyBlock(this.ClipperFix, this.Pads[j].parentNode);					if (typeof this.Clippers[j] != 'undefined')					{						this.Left[j] = AMI.find( '.' + this.LeftArrow, this.Pads[j])[0]; // There must be only one ([0]) element						this.Right[j] = AMI.find( '.' + this.RightArrow, this.Pads[j])[0];						this.ClippersWidth[j] = Math.max( this.Clippers[j].clientWidth - this.Left[j].offsetWidth - this.Right[j].offsetWidth, 50 );						this.Wrappers[j] = this.Pads[j].parentNode;					}				}				// Setting sizes				for ( var j = 0 ; j <= this.Pads.length - 1 ; j++ )				{					var Up = AMI.find( '.' + this.UpArrow, this.Pads[j])[0];					var Down = AMI.find( '.' + this.DownArrow, this.Pads[j])[0];					// Finding all blocks					if (typeof this.Clippers[j] != 'undefined')					{						this.Container = this.findFirstKeyBlock(this.ContainerFix, this.Clippers[j]);						if (this.Container)						{							// Collecting all slides in container to array							this.collectSlides();														if (this.Slides && this.Slides.length > 0)							{								// Define sizes of clipper and container from attributes								this.defineSizes(j);								var we_need_scroller_here = (this.SlideWidth * this.Slides.length > this.ClippersWidth[j]);								if (we_need_scroller_here)								{									this.Container.style.position = 'absolute'; // AFTER slide width detection																		// No attributes in clipper and container tag -> smart logic									if (this.ClipperSizeX == 0 && this.ClipperSizeY == 0 && this.ContainerSizeX == 0 && this.ContainerSizeY == 0)									{										this.defineSizesSmart(j);									}									this.setSizes(j);																		this.InitArrows(j, Up, Down);																		// px sizes of wrapper									/*this.Wrappers[j].style.width = (parseInt(this.Clippers[j].style.width) + parseInt(this.Clippers[j].style.marginLeft) + parseInt(this.Clippers[j].style.marginRight)) + 'px';									this.Wrappers[j].style.height = (parseInt(this.Clippers[j].style.height) + parseInt(this.Clippers[j].style.marginTop) + parseInt(this.Clippers[j].style.marginBottom)) + 'px';*/								}							}						}					} // endif (this.Clippers[j])				}			} // endif this.Pads		}	},		/**	 * Collecting all slides in current container to this.Slides array	 */	collectSlides : function()	{		this.Slides = [];		for (var i = 0 ; i <= this.Container.childNodes.length - 1 ; i++ )		{			if (this.Container.childNodes[i].nodeType == 1) // is html tag			{				var this_is_slide = true;				for ( k = 0 ; k <= this.exception_class_words.length - 1 ; k++ )					if ( this.Container.childNodes[i].className.indexOf(this.exception_class_words[k]) != -1 )						this_is_slide = false;				if (this_is_slide)					this.Slides.push(this.Container.childNodes[i]);				else					this.Container.childNodes[i].parentNode.removeChild(this.Container.childNodes[i]);			}		}	},		setSizes : function(j)	{		// Defining px sizes of container and clipper		this.Container.style.width = this.ContainerSizeX * this.SlideWidth + 'px';		this.ClippersWidth[j] = this.ClipperSizeX * this.SlideWidth;		this.Clippers[j].style.width = this.ClippersWidth[j] + 'px';				// Set common width to all slides		for ( var i = 0 ; i <= this.Slides.length - 1 ; i++ )		{			var dwidth = 0; // padding of slide			if (window.getComputedStyle)			{				var styles = window.getComputedStyle(this.Slides[i], null);				dwidth = parseInt(styles.marginLeft) + parseInt(styles.marginRight) + parseInt(styles.paddingLeft) + parseInt(styles.paddingRight);			}			this.Slides[i].style.width = (this.SlideWidth - dwidth) + 'px';		}				// Geting the maximum height of slides		var maxheight = 0;		for ( var i = 0 ; i <= this.Slides.length - 1 ; i++ ) // Get max height			if (maxheight < this.Slides[i].offsetHeight) maxheight = this.Slides[i].offsetHeight;		this.SlideHeight = maxheight;		for ( var i = 0 ; i <= this.Slides.length - 1 ; i++ ) // Set max height to all slides			this.Slides[i].style.height = this.SlideHeight + 'px';				this.Container.style.height = this.ContainerSizeY * this.SlideHeight;		this.Clippers[j].style.height = this.ClipperSizeY * this.SlideHeight + 'px';	},		/**	 * smart detection of clipper and container sizes, if no attributes reseived	 */	defineSizesSmart : function(j)	{		this.ContainerSizeX = this.getCols(this.Slides[0]);				if (this.ContainerSizeX <= 0)			this.ContainerSizeX = this.Slides.length; // Default one row					this.ContainerSizeX = Math.min(this.ContainerSizeX, this.Slides.length); // if cols more than slides		this.ContainerSizeY = Math.ceil( this.Slides.length / this.ContainerSizeX );				this.ClipperSizeX = this.ContainerSizeX;		if (this.ClippersWidth[j] + 1 < this.ClipperSizeX * this.SlideWidth) // then clipper width less than container, and we need Left and Right arrows		{			this.ClipperSizeX = Math.floor(this.ClippersWidth[j] / this.SlideWidth); // Can be zero, see next "if"		}		var horizontal_scroll_imposible = false;		if (this.ClipperSizeX == 0) // Case when paddings for Left and Right arrows not enters, and only vertical scroll needed		{			horizontal_scroll_imposible = true;		}		if (horizontal_scroll_imposible) // Exseption when clippers width is too short		{			this.ClipperSizeX = 1;			this.ClipperSizeY = 1; // Number of rows in clipper in case vhen only vertical scroll is possible			this.ContainerSizeX = 1; // Case when ContainerSizeX may not be equal to cols			this.ContainerSizeY = this.Slides.length;						this.Clippers[j].style.marginLeft = '0px'; // Deleting margins for arrows left and right			this.Clippers[j].style.marginRight = '0px';			this.ClippersWidth[j] += this.Left[j].offsetWidth + this.Right[j].offsetWidth;			this.Clippers[j].style.width = this.ClippersWidth[j] + 'px';		}		else // Horizontal scroll possible, standart situation		{			if (this.DefaultClipperSizeY == 0) // DefaultClipperSizeY == 0 means infinity rows, i.e. no vertical scroll			{				this.ClipperSizeY = Math.ceil( this.Slides.length / this.ContainerSizeX );			}			else			{				this.ClipperSizeY = this.DefaultClipperSizeY;			}		}				this.SlideWidth = Math.floor( this.ClippersWidth[j] / this.ClipperSizeX); // new normalized width in px	},		/**	 * defining sizes of clipper in container from attributes	 */	defineSizes : function(j)	{		this.SlideWidth = this.Slides[0].offsetWidth; // slider width as is				// Define size of clipper and container		this.ClipperSizeX = this.ClipperSizeY = this.ContainerSizeX = this.ContainerSizeY = 0;				var cl_x = this.Clippers[j].getAttribute("data-ami-ui-scroller__cols");		if (cl_x) this.ClipperSizeX = parseInt(cl_x);		var cl_y = this.Clippers[j].getAttribute("data-ami-ui-scroller__rows");		if (cl_y) this.ClipperSizeY = parseInt(cl_y);				var cn_x = this.Container.getAttribute("data-ami-ui-scroller__cols");		if (cn_x) this.ContainerSizeX = parseInt(cn_x);		var cn_y = this.Container.getAttribute("data-ami-ui-scroller__rows");		if (cn_y) this.ContainerSizeY = parseInt(cn_y);				if (this.ContainerSizeX == 0 && this.ContainerSizeY == 0) // if not defined in attributes		{			var scroll_x = this.Container.getAttribute("data-ami-ui-scroller__scroll-x");			if (scroll_x)			{				this.ContainerSizeY = this.ClipperSizeY;				this.ContainerSizeX = Math.ceil( this.Slides.length / this.ContainerSizeY );			}			var scroll_y = this.Container.getAttribute("data-ami-ui-scroller__scroll-y");			if (scroll_y) 			{				this.ContainerSizeX = this.ClipperSizeX;				this.ContainerSizeY = Math.ceil( this.Slides.length / this.ContainerSizeX );			}		}				if (this.ClipperSizeX > 0)			this.ClippersWidth[j] = this.ClipperSizeX * this.SlideWidth;	},		/**	 * Find html block with Word in classname, in Source	 *	 * @returns FIRST element with WordInClassName in css class	 */	findFirstKeyBlock : function(WordInClassName, Source)	{		var node = Source || document;		var list = node.getElementsByTagName('*');		var length = list.length;		for( var i = 0 ; i < length ; i++ )		{			if ( list[i].className.indexOf(WordInClassName) >= 0 )			{				return list[i];			}		}		return false;	},		/**	 * Initializes arrows	 *	 * @j - current Scroller number	 */	InitArrows : function(j, Up, Down)	{		if (this.ClipperSizeX < this.ContainerSizeX)		{			this.Container.style.left = '0px'; //this.Left[j].offsetWidth			if (this.Left[j] && this.Right[j])			{				this.Clippers[j].style.marginLeft = this.Left[j].offsetWidth + 'px';				this.Clippers[j].style.marginRight = this.Right[j].offsetWidth + 'px';				this.Wrappers[j].style.width = (parseInt(this.Clippers[j].style.width) + this.Left[j].offsetWidth + this.Right[j].offsetWidth) + 'px';								this.Left[j].style.visibility = 'hidden';				this.Left[j].style.display = 'block';				this.Left[j].style.margin = (this.SlideHeight * this.ClipperSizeY / 2 - this.Left[j].offsetHeight / 2) + 'px 0px 0px 0px';				this.Left[j].style.visibility = 'visible';				this.DisableArrow(this.Left[j]);				this.Left[j].onclick = function(Container, SlideWidth, ClipperWidth, Left, Right)				{					return function() 					{						AMI.UI.Scroller.MoveToLeft(Container, SlideWidth, ClipperWidth, Left, Right);						return false;					}				}(this.Container, this.SlideWidth, this.ClippersWidth[j], this.Left[j], this.Right[j])				this.Right[j].style.visibility = 'hidden';				this.Right[j].style.display = 'block';				this.Right[j].style.margin = (this.SlideHeight * this.ClipperSizeY / 2 - this.Left[j].offsetHeight / 2) + 'px 0px 0px 0px';				this.Right[j].style.visibility = 'visible';				this.Right[j].onclick = function(Container, SlideWidth, ClipperWidth, Left, Right)				{					return function() 					{						AMI.UI.Scroller.MoveToRight(Container, SlideWidth, ClipperWidth, Left, Right);						return false;					}				}(this.Container, this.SlideWidth, this.ClippersWidth[j], this.Left[j], this.Right[j])			}		}		if (this.ClipperSizeY < this.ContainerSizeY)		{			this.Container.style.top = '0px'; //Up.offsetHeight + 						if (Up && Down)			{				this.Clippers[j].style.marginTop = Up.offsetHeight + 'px';				this.Clippers[j].style.marginBottom = Down.offsetHeight + 'px';				this.Wrappers[j].style.height = (this.Clippers[j].offsetHeight + Up.offsetHeight + Down.offsetHeight) + 'px';						Up.style.visibility = 'hidden';				Up.style.display = 'block';				Up.style.margin = '0px 0px 0px ' + (this.SlideWidth * this.ClipperSizeX / 2 - Up.offsetWidth / 2) + 'px';				Up.style.visibility = 'visible';				this.DisableArrow(Up);				Up.onclick = function(Container, SlideHeight, ClipperHeight, Up, Down)				{					return function() 					{						AMI.UI.Scroller.MoveToUp(Container, SlideHeight, ClipperHeight, Up, Down);						return false;					}				}(this.Container, this.SlideHeight, this.ClipperSizeY * this.SlideHeight, Up, Down)				Down.style.visibility = 'hidden';				Down.style.display = 'block';				Down.style.margin = '0px 0px 0px ' + (this.SlideWidth * this.ClipperSizeX / 2 - Down.offsetWidth / 2) + 'px';				Down.style.visibility = 'visible';				Down.onclick = function(Container, SlideHeight, ClipperHeight, Up, Down)				{					return function() 					{						AMI.UI.Scroller.MoveToDown(Container, SlideHeight, ClipperHeight, Up, Down);						return false;					}				}(this.Container, this.SlideHeight, this.ClipperSizeY * this.SlideHeight, Up, Down)			}		}	},		/**	 * Moving slider to the left	 */	MoveToLeft : function(Container, SlideWidth, ClipperWidth, Left, Right)	{		this.EnableArrow(Right);		if (!this.ArrowIsDisabled(Left))		{			var x = parseFloat(Container.style.left);			var ContainerWidth = Container.offsetWidth; // without padding  - Left.offsetWidth - Right.offsetWidth			if (typeof x != 'number' || isNaN(x))				x = 0;//Left.offsetWidth						var distance = Math.max( ClipperWidth - SlideWidth, SlideWidth );			distance = Math.min( distance, 0 - x );//Left.offsetWidth			Container.style.left = (x + distance) + "px";			if ((Container.style.left === '') || (parseInt(Container.style.left) >= 0))				this.DisableArrow(Left);		}	},		/**	 * Moving slider to the right	 */	MoveToRight : function(Container, SlideWidth, ClipperWidth, Left, Right)	{		this.EnableArrow(Left);		var RightArrowIsEnabled = !this.ArrowIsDisabled(Right);		if (RightArrowIsEnabled)		{			var x = parseFloat(Container.style.left);			var ContainerWidth = Container.offsetWidth; // without padding - Left.offsetWidth - Right.offsetWidth			if (typeof x != 'number' || isNaN(x))			{				x = 0;//Left.offsetWidth				//Container.style.left = x + 'px';			}			var distance = Math.max( ClipperWidth - SlideWidth, SlideWidth );			distance = Math.min( distance, ContainerWidth + x - ClipperWidth ); //+ Right.offsetWidth			Container.style.left = (x - distance) + "px";			if ( ContainerWidth + parseInt(Container.style.left) <= ClipperWidth)				this.DisableArrow(Right);		}	},		/**	 * Moving slider to the up	 */	MoveToUp : function(Container, SlideHeight, ClipperHeight, Up, Down)	{		this.EnableArrow(Down);		if (!this.ArrowIsDisabled(Up))		{			var x = parseFloat(Container.style.top);			var ContainerHeight = Container.clientHeight; // without padding - Up.offsetHeight - Down.offsetHeight			if (typeof x != 'number' || isNaN(x))				x = 0;//Up.offsetHeight						var distance = Math.max( ClipperHeight - SlideHeight, SlideHeight );			distance = Math.min( distance, 0 - x );//Up.offsetHeight			Container.style.top = (x + distance) + "px";			if ((Container.style.top === '') || (parseInt(Container.style.top) >= 0))				this.DisableArrow(Up)		}	},		/**	 * Moving slider to the down	 */	MoveToDown : function(Container, SlideHeight, ClipperHeight, Up, Down)	{		this.EnableArrow(Up);		if (!this.ArrowIsDisabled(Down))		{			var x = parseFloat(Container.style.top);			var ContainerHeight = Container.clientHeight; // without padding - Up.offsetHeight - Down.offsetHeight			if (typeof x != 'number' || isNaN(x))			{				x = 0;//Down.offsetHeight				//Container.style.top = x + 'px';			}						var distance = Math.max( ClipperHeight - SlideHeight, SlideHeight );			distance = Math.min( distance, ContainerHeight + x - ClipperHeight );// + Up.offsetHeight			Container.style.top = (x - distance) + "px";						if ( ContainerHeight + parseInt(Container.style.top) <= ClipperHeight)				this.DisableArrow(Down);		}	},		/**	 * return true if arrow is disabled or false if it enabled and can be clicked	 */	ArrowIsDisabled : function ( Arrow )	{		if (Arrow.className != 'undefined')			return (Arrow.className.indexOf(this.DisabledArrow) >= 0);		else			return false;	},		/**	 * Adding css modifier DisabledArrow to className, if enabled	 */	DisableArrow : function( Arrow )	{		if (Arrow.className != 'undefined' && !this.ArrowIsDisabled(Arrow))		{			Arrow.className += " " + this.DisabledArrow; // pre-space + modifier		}	},		/**	 * Deleting css modifier DisabledArrow from className, if disabled	 */	EnableArrow : function( Arrow ) {		if (Arrow.className != 'undefined' && this.ArrowIsDisabled(Arrow)) {			var pos = Arrow.className.indexOf(this.DisabledArrow);			var res = Arrow.className.slice(pos - 1, pos + this.DisabledArrow.length); // -1 for pre-space			Arrow.className = Arrow.className.replace(new RegExp(res,'g'), '');		}	},		/**	 * Getting X size of Clipper by css modifier (_cols_x)	 *	 * @element_defining_cols - element with _cols_x in css classname	 */	getCols : function( element_defining_cols )	{		var ColsPos = element_defining_cols.className.indexOf(this.ColsModifierPrefix); // Position of value of cols modifier		if (typeof ColsPos != 'undefined' && ColsPos > -1) // ColsPos is set		{			ColsPos += this.ColsModifierPrefix.length; // Position of number of cols			var cols = parseInt(element_defining_cols.className.slice(ColsPos, ColsPos + 2));			if (typeof cols === 'number' && cols > 0)				return cols;		}		return -1; // default - one row	}}AMI.$(document).ready(function(){ AMI.UI.Scroller.init(); });