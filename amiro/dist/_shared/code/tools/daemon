#!/usr/bin/perl

BEGIN {
    use FindBin;
    $BINPATH = $FindBin::Bin.'/';
    $DOCROOT = $BINPATH.'../../../';
    $LOGPATH = $DOCROOT.'_admin/_logs/';
    $SYSPATH = $DOCROOT.'_shared/sys/';
    $LIBPATH = $BINPATH.'lib/perl';
    
    # defaults, may be overridden in config.pl
    $CLIENT_TIMEOUT = 5;
    $ERR_EMAIL = 'support@websitemaster.ru';
    $PERL = $^X;
    $ACCEPT_ERR_MAX = 10;

    require $BINPATH.'config.pl' if -e $BINPATH.'config.pl';
}


use lib $LIBPATH;
use Error qw(:try);
use Exceptions;
use SI::IPC::FIFOServerConnection;
use SI::Logger;
use SI::Utils;
use SI::CMS::Utils;
use SI::Tar;


my $LOGFILE = $LOGPATH.'daemon.log';
#my $LOGFILE = '/dev/stdout';
my $ipcDir = $SYSPATH.'var/daemon/';
my $PID_FILE = $LOGPATH.'daemon.pid';
my $SELF_SCRIPT = $0;

open STDIN, '/dev/null';
open STDOUT, '>>'.$LOGFILE;
open STDERR, '>&STDOUT' or throw ErrException("Cannot dup stdout: $!");

my $logger = SI::Logger->new($LOGFILE,LL_NOTE,1);
my $exit = 0;
try {
    lockPidFile($PID_FILE);
} catch ErrException with {
    my $e = shift;
    $exit = 1;
    !$e->code && $logger->logException($e,'Cannot start');
};

$exit && exit;

$logger->log("START",LL_NOTE);

my ($conn,$cfg);
try {

    $cfg = SI::CMS::Utils::siteConfig($DOCROOT);
        
    $conn = SI::IPC::FIFOServerConnection->new($ipcDir,$CLIENT_TIMEOUT);
    $conn->listen();
    $logger->log("Listening on $ipcDir",LL_NOTE);
    while(1) {

        for(my $i=0; !$conn->accept() && $i<$ACCEPT_ERR_MAX; $i++) {
            $logger->log("Cannot accept client connection: protocol error",LL_ERROR);
        }
        $i==$ACCEPT_ERR_MAX && throw ErrException('Too many protocol errors');

        try {
            my $daemonCmd = '';
            my $pack = '';
            $logger->log("Client connection");
            $pack = $conn->recv();
            !defined $pack && throw ErrException("Client closed connection immediately");
            my (@acmd,$data); 
            next if !parseCommandPacket($pack,\@acmd,\$data,$logger);
            $logger->log("Got command: @acmd",LL_NOTE);
            my $auth = shift(@acmd);
            # TODO: check auth
            my $cmd = shift(@acmd);
            my $args = "@acmd";

            my $res = '200 OK';

            try {
                if($cmd eq 'ping') {
                    # do nothing
                } elsif($cmd eq 'restart') {
                    $daemonCmd = 'restart';
                } elsif($cmd eq 'stop') {
                    $daemonCmd = 'stop';
                } elsif($cmd eq 'untar') {
                    my $fname = shift(@acmd);
                    my $docroot = shift(@acmd);
                    my $op = shift(@acmd);
                    my $tar = SI::Tar->new($fname);
                    $logger->log("Unpacking $fname into $DOCROOT",LL_NOTE);
                    $tar->extractArchive($DOCROOT,TAR_ERR_UTIME);
                    my @warns = $tar->warnings;
                    scalar @warns && $logger->log("Extract done with warnings:\n@warns",LL_WARN);

                    if($op eq 'open') {
                        $logger->log("Opening docroot for writing",LL_NOTE);
                        SI::CMS::Utils::setFilePermissions($DOCROOT,'update',0);
                    } else {
                        SI::CMS::Utils::setFilePermissions($DOCROOT,'runtime',0);
                    }
                } elsif($cmd eq 'close_docroot') {
                        $logger->log("Closing docroot",LL_NOTE);
                        SI::CMS::Utils::setFilePermissions($DOCROOT,'runtime',0);
                } else {
                    $res = "500 Unknown command '$cmd'";
                    notify($res,$logger);
                }
            } catch ErrException with {
                my $e = shift;
                $res = "500 ERROR ".$e->myMsg;
                notify("Operation failed:\n$res",$logger);
            };

            $logger->log("Reply: $res",LL_NOTE);
            $conn->send($res);

            if($daemonCmd eq 'restart') {
                close($pidFile);
                $logger->log("RESTART",LL_NOTE);
                exec "$PERL $SELF_SCRIPT";
            } elsif($daemonCmd eq 'stop') {
                close($pidFile);
                $logger->log("SHUTDOWN",LL_NOTE);
                exit;
            }
        } catch ErrException with {
            my $e = shift;
            $logger->logException($e,"Error communicating with client");
            notify("Error communicating with client",$logger);
        } finally {
            $conn->close();
        };
    }
} catch ErrException with {
    my $e = shift;
    $logger->logException($e,"FATAL ERROR");
    notify("FATAL ERROR",$logger);
} finally {
    $conn->shutdown();
};


sub notify {

    my $msg = shift;
    my $logger = shift;

    my $url = $cfg->{ROOT_PATH_WWW}->{value};
    my $body = "URL: $url\n";
    $body .= "ERR: $msg\n\n";
    $body .= $logger->historyAsText."\n" if defined $logger;
    try {
        sendMail(
            $ERR_EMAIL,
            "Single mode daemon error [$url]",
            $body,
            {From=>"Single Mode Daemon"}
        );
    } catch ErrException with {
        my $e = shift;
        defined $logger && $logger->logException($e,"Cannot send mail to $ERR_EMAIL");
    };
}

sub parseCommandPacket {

    my $pack = shift;
    my $cmd = shift;
    my $data = shift;
    my $logger = shift;

    my @lines = split(/\n/,$pack);
    my @cmds = split(/\s+/,shift(@lines));
    if(shift(@cmds) ne 'auth') {
        $logger->log("Auth not found in packet:\n\n$pack",LL_ERROR);
        return 0;
    }
    @$cmd = @cmds;
    $data = join('',@lines);
    return 1;
}

